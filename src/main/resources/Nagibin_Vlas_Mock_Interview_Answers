1. Что такое ООП?

ООП - это одна из парадигм программирования, в основе которой лежит система, состоящая из множества взаимодействующих друг с другом объектов.

2. Принципы ООП?

I. Абстракция - выделение значимой информации и исключение незначимой. Другими словами,
это правильное разделение системы на объекты

II. Полиморфизм - это св-во системы, позволяющее работать с интерфейсом объекта, не зная кокретного типа и внутренней структуры этого объекта. Полиморфизм делится на два типа:
а) статический полиморфизм - вызов перегруженных методов при компиляции программы;
б) динамический полиморфизм - вызов переопределенных методов сущностей реализующих общую абстракцию (абстрактный класс, интерфейс) во время выполнения программы.

III. Инкапсуляция - это свойство системы позволяющее объединять данные и методы работающие с ними в классе. Что касается Java, инкапсуляция это сокрытие реализации, которое так же можно достичь с помощью применения модификаторов доступа public, package private, protected и private. Пример: двигатель который инкапсулирован в автомобиль. Человеку не нужно знать его внутреннее устройство, ему достаточно провернуть ключ в замке зажигания, чтобы завести машину.

IV. Наследование - это свойство системы, позволяющее создать класс на основе уже имеющегося класса с частичной или полностью заимствущей функциональностью.

3. Разница между модификаторами доступа package private и protected?
Поля и методы с мод доступа package private - доступны другим сущностям в пределах пакета.
Поля и методы с мод доступа protected - доступны другим сущностям в пределах пакета и наследникам в пределах пакета. Если наследник будет создан за пределами пакета, то у него не будет доступа к полям и методам класса-родителя из другого пакета. Чтобы решить эту проблему, нужно переопределить методы класса-наследника.

4. Две категории типов данных?
I. Примитивные типы (byte, short, int, long, double, float, char, boolean) -  у каждого примитива есть свое дефолтное значение. Примитивы нужны для увеличения производительности систем, для уменьшения потребления памяти системой. Если примитиву присвоить null, то возникнет ошибка компиляции.

II. Ссылочные типы - по умолчанию null. Если объект содержит null, то может возникнуть исключение NullPointerException.

5. Перегрузка и переопределение методов?
Перегрузка - это создание метода с одинаковой сигнатурой, но с разным кол-вом параметров метода и их типов.
Переопределение - процесс переопределение реализации метода. Чтобы переопределить метод класса, нужно, чтобы класс наследовался либо от базового класса, либо имплементировал интерфейс.

6. Раннее связывание и позднее связывание?
Раннее (статическое) связывание:
I. происходит во время компиляции;
II. применяется для перегруженных методов;
III. применяется для private, static и final методов
IV. зависит от типа переменной

Позднее (динамическое) связывание:
I. происходит во время выполнения программы;
II. применяется для переопределнных методов
III. применяется для виртуальных (public) методов
IV. зависит от объекта

7. Статический и динамический полиморфизм (смотри вопрос 2)

8. Иерархия коллекций?
Иерархия коллекций -> иерархия интерфейсов
Iterable<E> => Collection<E> => List<E>
                             => Set<E> => SortedSet<E> => NavigableSet<E>
                             => Queue<E> => Dequeue<E>

Map<K,V> => SortedMap<K,V> => NavigableMap<K, V>

9. Что из себя представляет HashSet?
HashSet представляет из себя такую структуру данных как множество, то есть структуру данных содержащую множество уникальных значений. Под капотом работает как HashMap. Поиск, вставка, удаление => O(1). HashSet полезен в том случае, если над элементами нужно производить три операции: добавить, удалить и проверить, есть ли элемент в структуре.

10. В какой ситации я могу сказать, что в бакете есть коллизия?
В ситауции когда ключи двух или более элементов имеют одинаковый хэш код. Чтобы разрешить эту ситуацию HashMap использует метод equals() для сравнения элементов.

11. Почему предпочитают в качестве ключа элемента HashMap хранить иммутабельный объект?
Потому что неизменяемый объект имеет неизменяемый хэш код. 

12. Потеряется ли элемент в HashMap, мутабельный ключ которого будет изменен?
Да, такой элемент потеряется в HashMap, мы не сможем его найти, так как хэш код ключа старого элемента не равен хэш коду ключа измененного элемента. Данную проблему можно решить с помощью увеличения вместимости HashMap. В таком случае HashMap возьмет все свои элементы и перераспределит их по своим бакетам с учетом измененных ключей своих элементов.

13. При достижении 8 элементов структура бакета трансформируется из однонаправленного списка в красно-черное сбалансированное дерево, т.е. в TreeMap. На основе чего TreeMap сортирует элементы, клюи которых не Comparable<E>?
Сортировка на основе хэш кодов значений элементов.

14. Как сделать иммутабельный объект?
Сделать класс final, сделать все поля final, не выставляйте наружу методов-мутаторов, которые меняют состояние, не отдавайте наружу поля ссылочного изменяемого типа.

15. Как называется единственное не final поле в классе String?
Это полне называется hash (private int hash), к-й кэширует хэш код для string. Используется только в пределах класса, получить доступ к этому полю нельзя.

16. В HashSet нет метода получения элемента. Для чего это сделано?
Это коллекция хорошо подходит именно для хранения объектов, так как методы добавления, удаления, и проверки выполняются очень быстро, т.е. за O(1).

17. Size и capacity в ArrayList. Что это?
Size - количество элементов, хранящихся в списке
Capacity - вместимость списка, т.е количество элементов, которое может хранить список.

18. Какова сложность алгоритма добавления элемента в конец ArrayList и LinkedList?
LinkedList => O(n)
ArrayList => O(1). Если добавление элемента происходит одновременно с расширением списка (фммортизационная сложность), то - O(n)

20. Какова сложность добавления элемента в середину ArrayList и LinkedList?
LinkedList => O(n)
ArrayList => o(n)

21. Какова сложность добавления элемента в начало ArrayList и LinkedList?
LinkedList => O(1), потому что нужно поменять всего одну ссылку вне зависимости что идет дальше. Это единственный полезный случай когда нам потребовалось бы работать с LinkedList.
ArrayList => O(n)

22. Логирование... Как подлючать и настраивать логирование?



























